% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MTPS.R
\name{MTPS}
\alias{MTPS}
\title{Fit Models using Revised Stacking Algorithm}
\usage{
MTPS(
  xmat,
  ymat,
  xmat_list = NULL,
  family,
  cv = FALSE,
  residual = TRUE,
  nfold = 5,
  method_step1,
  method_step2,
  resid_type = c("deviance", "pearson", "raw"),
  resid_std = FALSE,
  dist1 = NULL,
  weights = NULL,
  weight2 = FALSE
)
}
\arguments{
\item{xmat}{Predictor matrix, each row is an observation vector.}

\item{ymat}{Responses matrix. Quantitative for family = "gaussian". A factor of two levels for family = "binomial". A survival object for family = "survival".}

\item{xmat_list}{The user defines a list to specify the number of subset columns of the xmat for each outcome.}

\item{family}{Response type for each response. If all response variable are within the same family, it can be "gaussian", "binomial" or "survival", otherwise it is a vector with elements "gaussian", "binomial", and "survival" to indicate each response family.}

\item{cv}{Logical, indicate if use Cross-Validation Stacking algorithm.}

\item{residual}{Logical, indicate if use Residual Stacking algorithm.}

\item{nfold}{Integer, number of folds for Cross-Validation Stacking algorithm. The default value is 5.}

\item{method_step1}{Base Learners for fitting models in Step 1 of Stacking Algorithm. It can be one base learner function for all outcomes or a list of base learner functions for each outcome. The list of all base learners can be obtained by \code{list.learners()}.}

\item{method_step2}{Base Learners for fitting models in Step 2 of Stacking Algorithm.}

\item{resid_type}{The residual type for Residual Stacking.}

\item{resid_std}{Logical, whether or not use standardized residual.}

\item{dist1}{Assumed distribution for response variable. If the argument is a character string, then it is assumed to name an element from \code{"survreg.distributions"}. These include "weibull", "exponential", "gaussian", "logistic", "lognormal", and "loglogistic".}

\item{weights}{A logical indicating whether to use weight for response in step1.}

\item{weight2}{A logical indicating whether to use weight for response in step2. The default is FALSE.}
}
\value{
It returns an MTPS object. It is a list of 4 parameters containing information about step 1 and step 2 models and the revised stacking algorithm method.
}
\description{
Fit a model using standard stacking algorithm or revised stacking algorithms to simultaneously predict multiple outcomes.
}
\examples{
data("HIV")
set.seed(1)
xmat <- as.matrix(XX)
ymat <- as.matrix(YY)
id <- createFolds(rowMeans(XX), k=5, list=FALSE)
training_id <- id != 1
y_train <- ymat[training_id, ]
y_test  <- ymat[!training_id, ]
x_train <- xmat[training_id, ]
x_test  <- xmat[!training_id, ]

# Residual Stacking
fit_rs <- MTPS(xmat = x_train, ymat = y_train,
               family = "gaussian", cv = FALSE, residual = TRUE,
               method_step1 = rpart1, method_step2 = lm1)
pre1 <- predict(fit_rs, x_test)

# Using different base learners for different outcomes
fit_mix_out <- MTPS(xmat = x_train, ymat = y_train,
                    family = "gaussian", cv = FALSE, residual = TRUE,
                    method_step1 = c(rpart1, lm1, rpart1, lm1, lm1),
                    method_step2 = c(rpart1, lm1, lm1, lm1, lm1))
pre2 <- predict(fit_mix_out, x_test)

# Residual Stacking for Survival Analysis
set.seed(1)
data("simdat_mtps")
id_train <- sample(1:100, 80)
xmat_train <- xmat[id_train, ]
xmat_test <- xmat[-id_train, ]
ymat_train <- cbind(list(survival::Surv(ymat[id_train, "time01"], ymat[id_train, "status01"])),
                    list(survival::Surv(ymat[id_train, "time02"], ymat[id_train, "status02"])))
weights <- find_km_weights_mat(ymat[id_train, ], num_outcome = 2)

xmat_list <- list(c(1), c(2))
fit <- MTPS(xmat_train, ymat_train, xmat_list = xmat_list, family = 'survival',
            cv = FALSE, residual = TRUE, nfold = 5, method_step1 = surv,
            method_step2 = lm1, dist1 = "lognormal", weights = weights)
pre3 <- predict.MTPS(fit, xmat_test)
}
